---
- |
    ## 10.7 总结

    迟到了 1 小时？

    没有状态，T1 码了 11K，还炸了（$10pts$），没时间推 dp 了。。。

    [欢迎观摩 477 行 12K 屎山。](https://www.codecopy.cn/post/nkdwhu)

- children:
    - |
        ### T1 XYD 15193

        就是给定三视图，让你还原一个六连通的立体图。

        先把不能放方块的扣掉，然后剩下的部分不一定连通。

        于是我打了神秘的 10K 代码，也就是考虑扣掉一些不连通的部分，however，不是过不了这个样例就是过不了那个样例。

        ~~然后这 10K 有至少 4K 是没卵用的。~~

        于是正难则反，考虑保留哪些连通块，dfs 搜出来，在三视图 check。

        但是 check 打了 $N^3$ 直接炸掉了，少了 $10pts$。

        于是改掉，变成 12K。

        其实调了很久（因为没有可视化，不知道自己的代码在干嘛），将近 11 点，都没时间打 T2、T3 了。

        下拉关于可视化。

    - |
        ##### 关于可视化

        首先讲一下如何在 ggb 的三次元模式如何使用代码。

        > 先描一个点，右键设置他，点进脚本，选拖动结束时，把代码拷进去，然后拖一下。

        然后根据这个原理，就可以用赋值语句生成立方体了。

        给出代码：

        ```cpp
        string add(int x, int y, int z)
        {
            static int cnt = 0;
            --x, --y, --z;
            return "a_{" + to_string(++cnt) + "}=Cube((" + to_string(x) + "," + to_string(y) + "," + to_string(z) + "),(" + to_string(x + 1) +
                "," + to_string(y) + "," + to_string(z) + "),(" + to_string(x + 1) + "," + to_string(y + 1) + "," + to_string(z) + "))\n";
        }

        void visual(int tmp[N][N][N])
        {
            for (int i = 1; i <= n; ++i)
            {
                for (int j = 1; j <= n; ++j)
                {
                    for (int k = 1; k <= n; ++k)
                    {
                        if (tmp[i][j][k])
                        {
                            cerr << add(k, i, n + 1 - j);
                        }
                    }
                }
            }
            cerr << '\n';
        }
        ```

- |
    ### T2 XYD 15194

    又是神秘概率 dp。

    题目大意就是你要开门从 0 走到 n，然后卡门后会等概率关上一扇门。

    问期望最少开门次数。

    设一个 dp，$f_{i,j}$ 表示走到了 $i$，有 $j$ 扇门跑到了后面，转移时 naive 的。

    没有打，以为有后效性被吓到了，实际上多开以维记一下就行。

- |
    ### T3 XYD 15195

    同上。

    题意就是一个含有 $1\sim n$ 的集合的幂集，问你这个幂集有多少个子集满足每个数至少被选两次。

    正难则反，考虑容斥掉至多选了一个的方案。

    设 $g_{i,j}$ 为有 $i$ 个数至多选了一次，有 $j$ 个数被选了一次。

    类似斯特林转移。

- |
    ### T4 XYD 15196

    给定序列 $A,B$，多次询问区间 $[L,R]$ 有多少子区间 $[l,r]$ 满足 $\min A_{l,\dots,r}=\min B_{l,\dots,r}\land\max A_{l,\dots,r}=\max B_{l,\dots,r}$。

    有一个 wmd 神秘做法，就是对于所有 $A_i>B_i$，就交换他们，这样限制就被拆开了，（特判掉 $A_i=B_i$ 后），就是 $A$ 区间中最小值出现两次，$B$ 区间中最大值出现两次，有 $64pts$，似乎有前途。

    正解还是正难则反，考虑扣掉不满足的区间，变为扫描线问题。

    依旧是考虑每个数作为最值的极长区间，分别更新。

    好吧，写了这么多还是 $24pts$，不过重要的是思维。

- |
    ## 总评

    多正难则反，不要乱码屎山。
