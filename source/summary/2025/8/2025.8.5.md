---
- |
    ## 8.5 总结

    好难，因为子任务挂了 $18$ 分。

- children:
    - |
        ### T1

        <https://www.luogu.com.cn/problem/P8864>

        矩乘套四边形不等式优化 dp。

    - |
        其实第一步是转化。

        你发现很难直接做，直接求一遍前缀异或和，发现操作变为交换相邻两个数。

        不是人想的。

        所以 dp 都没打出来。

        话说 $O(n^3k)$ 能过 $n=400,k=300$。。。

- children:
    - |
        ### T2

        <https://www.luogu.com.cn/problem/P7408>

        优化贪心。

        贪心做法即某年 CSP-J T2。

    - |
        优化：

        看到第三个子任务，考虑离线。

        看到第二个子任务，考虑维护 $u$。

        然后就不会了。

- children:
    - |
        ### T3

        <https://www.luogu.com.cn/problem/P10433>

        赛时比较有思路。

        但是 bfs 打炸了，于是挂了 $7$ 分。

    - |

        令 $cnt=\sum_{ch\in S}[ch=0]$，即重新激活单元格的个数。

        赛时只想了 $cnt\geq n-2$ 的做法，还想歪了，以下简称终止单元格为洞（某明奇妙就想这样叫）。

        1. $cnt=n$，等价于单源最短路；
        2. $cnt=n-1$，如果要经过洞，需加上其他玩家走到洞的贡献；
        3. $cnt=n-2$，如果要第一次经过洞，需加上其他玩家走到最近的洞的贡献，第二次经过洞：<br>
            两个洞相连，$k-1$ 个人都花 $1$ 步走到另一个洞；<br>
            否则每个人都花 $2$ 步走出去再走回来。

        很明显，其他玩家直接跑 dijsktra 即可，对于 $1$ 玩家，跑 bfs 即可。

        很明显 bfs 要多记录一个有没有经过洞，所以距离数组要开两维。

        _~~但是没开所以炸了。~~_

        如何扩展？每个人都走进最近的洞，然后再走进走出或进另一个洞？

        很明显可以先花费额外的步数走进两个相连的大洞，这样每次就只贡献 $1$ 步了。

    - |
        正解：

        每个玩家每轮产生的贡献都是一个分段一次函数（前面斜率为 $2$，后面为 $1$）。

        <details class="info-box" style="background-color: #dcf3ff; border-left: 4px solid #3676ff; padding: 10px; margin: 10px 0; border-radius: 4px;"><summary style="margin-bottom: 10px; font-weight: bold; cursor: pointer;"
        >拷来的正解</summary>

        假设棋子 $1$ 经过了 $x$ 个停止单元格，那么 $2\sim k$ 号棋子也都要走 $k$ 次，我们只需分别最小化它们的步数。

        由于图是无向图，故对于 $2\sim k$ 而言，一个显然的贪心是先走到一个停止单元格，然后每次只需花费 $2$ 的代价。

        但还有一种情况是走到两个相邻的单元格然后反复横跳，这样每次只需花费 $1$ 的代价。

        于是不难发现，$2\sim k$ 每个棋子 $i$ 的代价可以表示成 $f(i)=\min(x+A_i,2x+B_i)$ 的形式，其中 $A$ 和 $B$ 可以用 01bfs 求出。

        我们在跑最短路的过程中记录 $x$，就得到了一个 $\mathcal O(n^2)$ 的做法。

        注意到 $x$ 每 $+1$，答案就会增加 $k-1$，因此设 $1$ 号棋子到 $T$ 的最短路为 $d$，则 $x-d$ 是 $\mathcal O(\dfrac nk)$ 级别的，这样我们就得到了一个 $\mathcal O(\dfrac{n^2}k)$ 的做法。

        注意到 $\sum_if(i)$ 是一个段数是 $\mathcal O(k)$ 的凸函数，因此考虑对每一段分别求解。

        显然我们可以将线段延申成直线，于是我们只需把贡献拆到每条边上跑最短路即可，这个做法的时间复杂度是 $\mathcal O(nk\log n)$。

        取 $k=\mathcal O\left(\dfrac{\sqrt{n\log n}}{\log n}\right)$ 平衡，可以得到 $\mathcal O(n\sqrt{n\log n})$ 的时间复杂度。
        </details>

- |
    ## 总评

    需要丰富的想象力（不愧是想象学）。
